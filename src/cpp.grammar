@precedence {
  capture
  subscript
  arguments
  suffix @left
  pointer @left
  mult @left
  add @left
  bitShift @left
  sizeof
  greaterLess @left
  equal @left
  bitAnd @left
  bitXor @left
  bitOr @left
  logic @left
  params
  array
  specifiers
  cast
  more
  subscriptDesignator
  return
  typeIdentifier
  structName
  namespace
  else @right
  caseLabel
  simpleTypeIdentifier
  reference
  qualifiers
  statement
  pack
  assign @right
  ternary @right
}

@top TranslationUnit {
  topLevelItem*
}

topLevelItem {
  FunctionDefinition |
  LinkageSpecification |
  Declaration |
  statement |
  TypeDefinition |
  emptyDeclaration |
  PreprocIf |
  PreprocIfdef |
  PreprocInclude |
  PreprocDef |
  PreprocFunctionDef |
  PreprocCall |
  NamespaceDefinition |
  UsingDeclaration |
  AliasDeclaration |
  StaticAssertDeclaration |
  TemplateDeclaration |
  TemplateInstantiation |
  FunctionDefinition { ConstructorOrDestructorDefinition } |
  FunctionDefinition { OperatorCastDefinition } |
  Declaration { OperatorCastDeclaration }
}

PreprocInclude {
  token_2 (StringLiteral | SystemLibString | Identifier | CallExpression { PreprocCallExpression }) "\n"
}

PreprocDef {
  token_3 Identifier PreprocArg? "\n"
}

PreprocFunctionDef {
  token_4 Identifier PreprocParams PreprocArg? "\n"
}

PreprocParams {
  "(" commaSep<Identifier | "..."> ")"
}

PreprocCall {
  PreprocDirective PreprocArg? "\n"
}

PreprocIf {
  token_5 preprocExpression "\n" topLevelItem* (PreprocElse | PreprocElif)? token_6
}

PreprocIfdef {
  (token_7 | token_8) Identifier topLevelItem* (PreprocElse | PreprocElif)? token_9
}

PreprocElse {
  token_10 topLevelItem*
}

PreprocElif {
  token_11 preprocExpression "\n" topLevelItem* (PreprocElse | PreprocElif)?
}

PreprocIfInFieldDeclarationList {
  token_12 preprocExpression "\n" fieldDeclarationListItem* (PreprocElse { PreprocElseInFieldDeclarationList } | PreprocElif { PreprocElifInFieldDeclarationList })? token_13
}

PreprocIfdefInFieldDeclarationList {
  (token_14 | token_15) Identifier fieldDeclarationListItem* (PreprocElse { PreprocElseInFieldDeclarationList } | PreprocElif { PreprocElifInFieldDeclarationList })? token_16
}

PreprocElseInFieldDeclarationList {
  token_17 fieldDeclarationListItem*
}

PreprocElifInFieldDeclarationList {
  token_18 preprocExpression "\n" fieldDeclarationListItem* (PreprocElse { PreprocElseInFieldDeclarationList } | PreprocElif { PreprocElifInFieldDeclarationList })?
}

preprocExpression {
  Identifier |
  CallExpression { PreprocCallExpression } |
  NumberLiteral |
  CharLiteral |
  PreprocDefined |
  UnaryExpression { PreprocUnaryExpression } |
  BinaryExpression { PreprocBinaryExpression } |
  ParenthesizedExpression { PreprocParenthesizedExpression }
}

PreprocParenthesizedExpression {
  "(" preprocExpression ")"
}

PreprocDefined {
  kw<"defined"> "(" Identifier ")" |
  kw<"defined"> Identifier
}

PreprocUnaryExpression {
  UnaryOp preprocExpression
}

PreprocCallExpression {
  Identifier !arguments ArgumentList { "(" commaSep<preprocExpression> ")" }
}

PreprocBinaryExpression {
  preprocExpression !add ArithOp<"+" | "-"> preprocExpression |
  preprocExpression !mult ArithOp<"*" | "/" | "%"> preprocExpression |
  preprocExpression !logic LogicOp<"||" | "&&"> preprocExpression |
  preprocExpression !bitOr BitOp<"|"> preprocExpression |
  preprocExpression !bitXor BitOp<"^"> preprocExpression |
  preprocExpression !bitAnd BitOp<"&"> preprocExpression |
  preprocExpression !equal CompareOp<"==" | "!="> preprocExpression |
  preprocExpression !greaterLess CompareOp<("<" | ">") "="?> preprocExpression |
  preprocExpression !bitShift BitOp<"<<" | ">>"> preprocExpression
}

FunctionDefinition {
  Attribute* MsCallModifier? declarationSpecifiers declarator CompoundStatement
}

Declaration {
  Attribute* declarationSpecifiers commaSep1<declarator | InitDeclarator> ";"
}

TypeDefinition {
  kw<"typedef"> TypeQualifier* typeSpecifier commaSep1<typeDeclarator> ";"
}

declarationSpecifiers {
  (StorageClassSpecifier | TypeQualifier | AttributeSpecifier | MsDeclspecModifier)* ~specifiers typeSpecifier (StorageClassSpecifier | TypeQualifier | AttributeSpecifier | MsDeclspecModifier)*
}

LinkageSpecification {
  kw<"extern"> StringLiteral (FunctionDefinition | Declaration | DeclarationList)
}

AttributeSpecifier {
  kw<"__attribute__"> "(" ArgumentList ")"
}

MsDeclspecModifier {
  kw<"__declspec"> "(" Identifier ")"
}

MsBasedModifier {
  kw<"__based"> ArgumentList
}

MsCallModifier {
  kw<"__cdecl"> |
  kw<"__clrcall"> |
  kw<"__stdcall"> |
  kw<"__fastcall"> |
  kw<"__thiscall"> |
  kw<"__vectorcall">
}

MsRestrictModifier {
  kw<"__restrict">
}

MsUnsignedPtrModifier {
  kw<"__uptr">
}

MsSignedPtrModifier {
  kw<"__sptr">
}

MsUnalignedPtrModifier {
  kw<"_unaligned"> |
  kw<"__unaligned">
}

MsPointerModifier {
  MsUnalignedPtrModifier |
  MsRestrictModifier |
  MsUnsignedPtrModifier |
  MsSignedPtrModifier
}

DeclarationList {
  "{" topLevelItem* "}"
}

declarator {
  PointerDeclarator |
  FunctionDeclarator |
  ArrayDeclarator |
  ParenthesizedDeclarator |
  Identifier ~identifier |
  ReferenceDeclarator |
  ScopedIdentifier ~identifier |
  TemplateFunction ~identifier |
  OperatorName |
  DestructorName |
  StructuredBindingDeclarator
}

fieldDeclarator {
  PointerDeclarator {
    MsBasedModifier? "*" MsPointerModifier* TypeQualifier* fieldDeclarator
  } |
  FunctionDeclarator {
    fieldDeclarator !params ParameterList (TypeQualifier | virtualSpecifier | Noexcept | ThrowSpecifier | TrailingReturnType)*
  } |
  ArrayDeclarator {
    fieldDeclarator !array "[" TypeQualifier* (expression | "*")? "]"
  } |
  ParenthesizedDeclarator {
    "(" fieldDeclarator ")"
  } |
  FieldIdentifier |
  ReferenceDeclarator {
    ("&" | "&&") fieldDeclarator
  } |
  TemplateMethod |
  OperatorName
}

typeDeclarator {
  PointerDeclarator { PointerTypeDeclarator } |
  FunctionDeclarator { FunctionTypeDeclarator } |
  ArrayDeclarator { ArrayTypeDeclarator } |
  ParenthesizedDeclarator { ParenthesizedTypeDeclarator } |
  TypeIdentifier
}

abstractDeclarator {
  AbstractPointerDeclarator |
  AbstractFunctionDeclarator |
  AbstractArrayDeclarator |
  AbstractParenthesizedDeclarator |
  AbstractReferenceDeclarator
}

ParenthesizedDeclarator {
  "(" declarator ")"
}

ParenthesizedTypeDeclarator {
  "(" typeDeclarator ")"
}

AbstractParenthesizedDeclarator {
  "(" abstractDeclarator ")"
}

PointerDeclarator {
  MsBasedModifier? "*" MsPointerModifier* TypeQualifier* declarator
}

PointerTypeDeclarator {
  MsBasedModifier? "*" MsPointerModifier* TypeQualifier* typeDeclarator
}

AbstractPointerDeclarator {
  "*" (!qualifiers TypeQualifier)* abstractDeclarator?
}

FunctionDeclarator {
  declarator !params ParameterList !specifiers AttributeSpecifier*
  (!specifiers (TypeQualifier | virtualSpecifier | Noexcept | ThrowSpecifier | TrailingReturnType))*
}

FunctionTypeDeclarator {
  typeDeclarator !params ParameterList
}

AbstractFunctionDeclarator {
  abstractDeclarator? !params ParameterList (TypeQualifier | Noexcept | ThrowSpecifier)* !return TrailingReturnType?
}

ArrayDeclarator {
  declarator !array "[" TypeQualifier* (expression | "*")? "]"
}

ArrayTypeDeclarator {
  typeDeclarator !array "[" TypeQualifier* (expression | "*")? "]"
}

AbstractArrayDeclarator {
  abstractDeclarator? !array "[" TypeQualifier* (expression | "*")? "]"
}

InitDeclarator {
  declarator "=" (InitializerList | expression) |
  declarator (!arguments ArgumentList | InitializerList)
}

CompoundStatement {
  !statement "{" topLevelItem* !statement "}"
}

StorageClassSpecifier {
  kw<"extern"> |
  kw<"static"> |
  kw<"register"> |
  kw<"inline">
}

TypeQualifier {
  kw<"const"> |
  kw<"volatile"> |
  kw<"restrict"> |
  kw<"_Atomic"> |
  kw<"mutable"> |
  kw<"constexpr">
}

typeSpecifier {
  StructSpecifier |
  UnionSpecifier |
  EnumSpecifier |
  ClassSpecifier |
  SizedTypeSpecifier |
  primitiveType |
  TemplateType |
  Auto |
  DependentType |
  Decltype |
  (ScopedTypeIdentifier !simpleTypeIdentifier | TypeIdentifier !simpleTypeIdentifier)
}

SizedTypeSpecifier {
  (kw<"signed"> | kw<"unsigned"> | kw<"long"> | kw<"short">)+ (TypeIdentifier | primitiveType)?
}

EnumSpecifier {
  kw<"enum"> (kw<"class"> | kw<"struct">)? !structName (className enumBaseClause? EnumeratorList? | EnumeratorList)
}

EnumeratorList {
  "{" commaSepTrailing<Enumerator> "}"
}

StructSpecifier {
  kw<"struct"> MsDeclspecModifier? !structName (className | className? virtualSpecifier? BaseClassClause? FieldDeclarationList)
}

UnionSpecifier {
  kw<"union"> MsDeclspecModifier? !structName (className | className? virtualSpecifier? BaseClassClause? FieldDeclarationList)
}

FieldDeclarationList {
  "{" fieldDeclarationListItem* "}"
}

fieldDeclarationListItem {
  FieldDeclaration |
  PreprocDef |
  PreprocFunctionDef |
  PreprocCall |
  PreprocIf { PreprocIfInFieldDeclarationList } |
  PreprocIfdef { PreprocIfdefInFieldDeclarationList } |
  TemplateDeclaration |
  FunctionDefinition { InlineMethodDefinition } |
  FunctionDefinition { ConstructorOrDestructorDefinition } |
  Declaration { ConstructorOrDestructorDeclaration } |
  FunctionDefinition { OperatorCastDefinition } |
  Declaration { OperatorCastDeclaration } |
  FriendDeclaration |
  AccessSpecifier |
  AliasDeclaration |
  UsingDeclaration |
  TypeDefinition |
  StaticAssertDeclaration
}

FieldDeclaration {
  Attribute* kw<"virtual">? declarationSpecifiers commaSep<fieldDeclarator> (BitfieldClause | InitializerList | "=" (expression | InitializerList))? ";"
}

BitfieldClause {
  ":" expression
}

Enumerator {
  Identifier ("=" expression)?
}

ParameterList {
  "(" ~argOrParam commaSep<(ParameterDeclaration | OptionalParameterDeclaration | VariadicParameterDeclaration | "...")> ")"
}

ParameterDeclaration {
  Attribute* declarationSpecifiers (declarator | abstractDeclarator)?
}

statement {
  CaseStatement |
  nonCaseStatement |
  ForRangeLoop |
  TryStatement |
  ThrowStatement
}

nonCaseStatement {
  LabeledStatement |
  CompoundStatement |
  ExpressionStatement |
  IfStatement |
  SwitchStatement |
  DoStatement |
  WhileStatement |
  ForStatement |
  ReturnStatement |
  BreakStatement |
  ContinueStatement |
  GotoStatement
}

LabeledStatement {
  StatementIdentifier ":" statement
}

ExpressionStatement {
  (expression | CommaExpression)? ";"
}

IfStatement {
  kw<"if"> kw<"constexpr">? ConditionClause statement (!else kw<"else"> statement)?
}

SwitchStatement {
  kw<"switch"> ConditionClause CompoundStatement
}

CaseStatement {
  (kw<"case"> expression | kw<"default">) ":" (!caseLabel (nonCaseStatement | Declaration | TypeDefinition))*
}

WhileStatement {
  kw<"while"> ConditionClause statement
}

DoStatement {
  kw<"do"> statement kw<"while"> ParenthesizedExpression ";"
}

ForStatement {
  kw<"for"> "(" (Declaration | (expression | CommaExpression)? ";") expression? ";" (expression | CommaExpression)? ")" statement
}

ReturnStatement {
  kw<"return"> (expression | CommaExpression)? ";" |
  kw<"return"> InitializerList ";"
}

BreakStatement {
  kw<"break"> ";"
}

ContinueStatement {
  kw<"continue"> ";"
}

GotoStatement {
  kw<"goto"> StatementIdentifier ";"
}

expression {
  ConditionalExpression |
  AssignmentExpression |
  BinaryExpression |
  UnaryExpression |
  UpdateExpression |
  CastExpression |
  PointerExpression |
  SizeofExpression |
  SubscriptExpression |
  CallExpression |
  FieldExpression |
  CompoundLiteralExpression |
  Identifier ~identifier |
  NumberLiteral |
  StringLiteral |
  True |
  False |
  kw<"NULL"> |
  ConcatenatedString |
  CharLiteral |
  ParenthesizedExpression |
  TemplateFunction ~identifier |
  ScopedIdentifier ~identifier |
  NewExpression |
  DeleteExpression |
  LambdaExpression |
  ParameterPackExpansion |
  kw<"nullptr"> |
  kw<"this"> |
  RawStringLiteral
}

CommaExpression {
  expression !more "," (expression | CommaExpression)
}

ConditionalExpression {
  expression !ternary "?" expression ":" expression
}

assignmentLeftExpression {
  (Identifier |
   CallExpression |
   FieldExpression |
   PointerExpression |
   SubscriptExpression |
   ParenthesizedExpression |
   ScopedNamespaceIdentifier)
  !assign // FIXME why is this necessary?
}

AssignmentExpression {
  assignmentLeftExpression !assign ("=" | "*=" | "/=" | "%=" | "+=" | "-=" | "<<=" | ">>=" | "&=" | "^=" | "|=") expression
}

PointerExpression {
  ("*" | "&") !pointer expression
}

UnaryExpression {
  UnaryOp !suffix expression
}

BinaryExpression {
  expression !add ArithOp<"+" | "-"> expression |
  expression !mult ArithOp<"*" | "/" | "%"> expression |
  expression !logic LogicOp<"||" | "&&"> expression |
  expression !bitOr BitOp<"|"> expression |
  expression !bitXor BitOp<"^"> expression |
  expression !bitAnd BitOp<"&"> expression |
  expression !equal CompareOp<"==" | "!="> expression |
  expression !greaterLess CompareOp<("<" | ">") "="?> expression |
  expression !bitShift BitOp<"<<" | ">>"> expression
}

UpdateExpression {
  ("--" | "++") expression | expression !suffix ("--" | "++")
}

CastExpression {
  "(" TypeDescriptor ")" expression
}

TypeDescriptor {
  TypeQualifier* typeSpecifier TypeQualifier* abstractDeclarator?
}

SizeofExpression {
  kw<"sizeof"> !sizeof (expression | "(" TypeDescriptor ")") |
  kw<"sizeof"> "..." "(" Identifier ")"
}

SubscriptExpression {
  expression !subscript "[" expression "]"
}

CallExpression {
  expression !arguments ArgumentList |
  primitiveType !arguments ArgumentList
}

ArgumentList {
  "(" ~argOrParam commaSep<(expression | InitializerList)> ")"
}

FieldExpression {
  expression !subscript ("." | "->") FieldIdentifier |
  expression !subscript ("." | "->") (DestructorName | TemplateMethod)
}

CompoundLiteralExpression {
  "(" TypeDescriptor ")" InitializerList |
  (TypeIdentifier | TemplateType | ScopedTypeIdentifier) InitializerList
}

ParenthesizedExpression {
  "(" (expression | CommaExpression) ")"
}

InitializerList {
  "{" commaSepTrailing<InitializerPair | expression | InitializerList> "}"
}

InitializerPair {
  (SubscriptDesignator | FieldDesignator)+ "=" (expression | InitializerList)
}

SubscriptDesignator {
  "[" expression !subscriptDesignator "]"
}

FieldDesignator {
  "." FieldIdentifier
}

@skip {} {
  CharLiteral {
    charLiteralStart (EscapeSequence | charLiteralContent) charLiteralEnd
  }

  StringLiteral {
    stringLiteralStart (stringLiteralContent | EscapeSequence)* stringLiteralEnd
  }
}

ConcatenatedString {
  (RawStringLiteral | StringLiteral) (RawStringLiteral | StringLiteral)+
}

TypeIdentifier {
  !typeIdentifier identifier
}

FieldIdentifier {
  identifier
}

StatementIdentifier {
  identifier
}

Identifier {
  identifier
}

emptyDeclaration {
  typeSpecifier ";"
}

Decltype {
  kw<"decltype"> "(" expression ")"
}

ClassSpecifier {
  kw<"class"> MsDeclspecModifier? !structName (className | className? virtualSpecifier? BaseClassClause? FieldDeclarationList)
}

className {
  (TypeIdentifier | ScopedTypeIdentifier | TemplateType) !structName
}

virtualSpecifier {
  @specialize[name=VirtualSpecifier]<identifier, "final" | "override">
}

ExplicitFunctionSpecifier {
  kw<"explicit"> |
  kw<"explicit"> !arguments "(" expression ")"
}

BaseClassClause {
  ":" commaSep1<access? className "..."?>
}

enumBaseClause {
  ":" !typeIdentifier (ScopedTypeIdentifier | TypeIdentifier | SizedTypeSpecifier)
}

Auto {
  kw<"auto">
}

DependentType {
  kw<"typename"> typeSpecifier
}

TemplateDeclaration {
  kw<"template"> TemplateParameterList (emptyDeclaration | AliasDeclaration | Declaration | TemplateDeclaration | FunctionDefinition | FunctionDefinition { ConstructorOrDestructorDefinition } | FunctionDefinition { OperatorCastDefinition })
}

TemplateInstantiation {
  kw<"template"> declarationSpecifiers? declarator ";"
}

TemplateParameterList {
  "<" commaSep<
    ParameterDeclaration |
    OptionalParameterDeclaration |
    TypeParameterDeclaration |
    VariadicParameterDeclaration |
    VariadicTypeParameterDeclaration |
    OptionalTypeParameterDeclaration |
    TemplateTemplateParameterDeclaration
  > ">"
}

TypeParameterDeclaration {
  (kw<"typename"> | kw<"class">) !typeIdentifier TypeIdentifier?
}

VariadicTypeParameterDeclaration {
  (kw<"typename"> | kw<"class">) "..." !typeIdentifier TypeIdentifier?
}

OptionalTypeParameterDeclaration {
  (kw<"typename"> | kw<"class">) TypeIdentifier? "=" typeSpecifier
}

TemplateTemplateParameterDeclaration {
  kw<"template"> TemplateParameterList (TypeParameterDeclaration | VariadicTypeParameterDeclaration | OptionalTypeParameterDeclaration)
}

OptionalParameterDeclaration {
  declarationSpecifiers declarator? "=" expression
}

VariadicParameterDeclaration {
  declarationSpecifiers (VariadicDeclarator | ReferenceDeclarator { VariadicReferenceDeclarator })
}

VariadicDeclarator {
  "..." Identifier?
}

VariadicReferenceDeclarator {
  ("&&" | "&") VariadicDeclarator
}

OperatorCast {
  ((NamespaceIdentifier | TemplateType | ScopedNamespaceIdentifier)? "::")? kw<"operator"> declarationSpecifiers !cast abstractDeclarator
}

FieldInitializerList {
  ":" commaSep1<FieldInitializer>
}

FieldInitializer {
  (FieldIdentifier | ScopedFieldIdentifier) !arguments (InitializerList | ArgumentList) "..."?
}

InlineMethodDefinition {
  Attribute* kw<"virtual">? declarationSpecifiers
  fieldDeclarator (CompoundStatement | !more DefaultMethodClause | DeleteMethodClause)
}

OperatorCastDefinition {
  (StorageClassSpecifier | TypeQualifier | AttributeSpecifier)* ~specifiers (kw<"virtual"> | ExplicitFunctionSpecifier)? OperatorCast (CompoundStatement | DefaultMethodClause | DeleteMethodClause)
}

OperatorCastDeclaration {
  (kw<"virtual"> | ExplicitFunctionSpecifier)? OperatorCast ("=" expression)? ";"
}

ConstructorOrDestructorDefinition {
  (StorageClassSpecifier | TypeQualifier | AttributeSpecifier)* ~specifiers (kw<"virtual"> | ExplicitFunctionSpecifier)? FunctionDeclarator FieldInitializerList? (CompoundStatement | DefaultMethodClause | DeleteMethodClause)
}

ConstructorOrDestructorDeclaration {
  (kw<"virtual"> | ExplicitFunctionSpecifier)? FunctionDeclarator ";"
}

DefaultMethodClause {
  "=" kw<"default"> ";"
}

DeleteMethodClause {
  "=" kw<"delete"> ";"
}

FriendDeclaration {
  kw<"friend"> (Declaration | FunctionDefinition | (kw<"class"> | kw<"struct"> | kw<"union">)? className ";")
}

AccessSpecifier {
  access ":"
}

ReferenceDeclarator {
  ("&" | "&&") !reference declarator
}

AbstractReferenceDeclarator {
  ("&" | "&&") (!reference abstractDeclarator)?
}

StructuredBindingDeclarator {
  "[" commaSep1<Identifier ~identifier> "]"
}

TrailingReturnType {
  "->" TypeQualifier? typeSpecifier abstractDeclarator?
}

Noexcept {
  kw<"noexcept"> (!arguments "(" expression? ")")?
}

ThrowSpecifier {
  kw<"throw"> "(" commaSep<TypeDescriptor> ")"
}

TemplateType {
  (TypeIdentifier | ScopedTypeIdentifier) ~identifier TemplateArgumentList
}

TemplateMethod {
  (FieldIdentifier | ScopedFieldIdentifier) ~identifier TemplateArgumentList
}

TemplateFunction {
  (Identifier | ScopedIdentifier) ~identifier TemplateArgumentList
}

TemplateArgumentList {
  "<" commaSep<TypeDescriptor | ParameterPackExpansion { TypeDescriptor "..." } | expression> ">"
}

NamespaceDefinition {
  kw<"namespace"> Identifier? DeclarationList
}

UsingDeclaration {
  kw<"using"> kw<"namespace">? (Identifier | ScopedIdentifier) ";"
}

AliasDeclaration {
  kw<"using"> TypeIdentifier "=" TypeDescriptor ";"
}

StaticAssertDeclaration {
  kw<"static_assert"> "(" expression ("," (StringLiteral | RawStringLiteral | ConcatenatedString))? ")" ";"
}

ConditionClause {
  "(" ((Declaration | ExpressionStatement)? (expression | CommaExpression) | Declaration { ConditionDeclaration }) ")"
}

ConditionDeclaration {
  declarationSpecifiers declarator ("=" expression | InitializerList)
}

ForRangeLoop {
  kw<"for"> "(" declarationSpecifiers declarator ":" (expression | InitializerList) ")" statement
}

ThrowStatement {
  kw<"throw"> expression? ";"
}

TryStatement {
  kw<"try"> CompoundStatement CatchClause+
}

CatchClause {
  kw<"catch"> ParameterList CompoundStatement
}

Attribute {
  "[[" commaSep1<expression> "]]"
}

NewExpression {
  "::"? kw<"new"> ArgumentList? typeSpecifier NewDeclarator (!arguments (ArgumentList | InitializerList))?
}

NewDeclarator {
  "[" expression "]" (!more NewDeclarator)?
}

DeleteExpression {
  "::"? kw<"delete"> (!more "[" "]")? expression
}

LambdaExpression {
  LambdaCaptureSpecifier AbstractFunctionDeclarator? CompoundStatement
}

LambdaCaptureSpecifier {
  "[" (
    LambdaDefaultCapture |
    commaSep1<expression> |
    LambdaDefaultCapture "," commaSep1<expression> |
    ""
  ) "]" !capture
}

ParameterPackExpansion {
  expression !pack "..."
}

DestructorName {
  "~" Identifier
}

ScopedFieldIdentifier {
  (NamespaceIdentifier | TemplateType | ScopedNamespaceIdentifier)? !namespace "::" (FieldIdentifier | OperatorName | DestructorName)
}

ScopedIdentifier {
  (NamespaceIdentifier | TemplateType | ScopedNamespaceIdentifier)? !namespace "::" (Identifier | OperatorName | DestructorName)
}

ScopedTypeIdentifier {
  (NamespaceIdentifier | TemplateType | ScopedNamespaceIdentifier)? !namespace "::" TypeIdentifier
}

ScopedNamespaceIdentifier {
  (NamespaceIdentifier | TemplateType | ScopedNamespaceIdentifier)? !namespace "::" NamespaceIdentifier
}

NamespaceIdentifier {
  identifier !namespace
}

access { @specialize[name=Access]<identifier, "public" | "private" | "protected"> }

True { @specialize<identifier, "TRUE" | "true"> }

False { @specialize<identifier, "FALSE" | "false"> }

primitiveType {
  @specialize[name=PrimitiveType]<identifier,
    "bool" | "char" | "int" | "float" | "double" | "void" | "size_t" | "ssize_t" |
    "intptr_t" | "uintptr_t" | "charptr_t" | "int8_t" | "int16_t" | "int32_t" |
    "int64_t" | "uint8_t" | "uint16_t" | "uint32_t" | "uint64_t" | "char8_t" |
    "char16_t" | "char32_t" | "char64_t">
}

kw<term> { @specialize[name={term}]<identifier, term> }

commaSep<term> { "" | term ("," term)* }

commaSep1<term> { term ("," term)* }

commaSepTrailing<term> { "" | term ("," term?)* }

@skip { whitespace | Comment }

@external tokens token from "./tokens" { RawStringLiteral }

@tokens {
  whitespace {
    ($[ \t\r\n] | "\\" "\r"? "\n")+
  }
  token_2 {
    "#" $[ 	]* "include"
  }
  token_3 {
    "#" $[ 	]* "define"
  }
  token_4 {
    "#" $[ 	]* "define"
  }
  token_5 {
    "#" $[ 	]* "if"
  }
  token_6 {
    "#" $[ 	]* "endif"
  }
  token_7 {
    "#" $[ 	]* "ifdef"
  }
  token_8 {
    "#" $[ 	]* "ifndef"
  }
  token_9 {
    "#" $[ 	]* "endif"
  }
  token_10 {
    "#" $[ 	]* "else"
  }
  token_11 {
    "#" $[ 	]* "elif"
  }
  token_12 {
    "#" $[ 	]* "if"
  }
  token_13 {
    "#" $[ 	]* "endif"
  }
  token_14 {
    "#" $[ 	]* "ifdef"
  }
  token_15 {
    "#" $[ 	]* "ifndef"
  }
  token_16 {
    "#" $[ 	]* "endif"
  }
  token_17 {
    "#" $[ 	]* "else"
  }
  token_18 {
    "#" $[ 	]* "elif"
  }
  PreprocDirective {
    "#" $[ \t]* $[a-zA-Z] $[a-zA-Z0-9_]*
  }
  PreprocArg {
    ![\n] | "\\\\" "\\r"? "\\n"+
  }
  NumberLiteral {
    $[-\+]? ("0x" | "0b")? (($[0-9]+ ("'" $[0-9]+)* | "0b" $[0-9]+ ("'" $[0-9]+)* | "0x" $[0-9a-fA-F]+ ("'" $[0-9a-fA-F]+)*) ("." ($[0-9a-fA-F]+ ("'" $[0-9a-fA-F]+)*)?)? | "." $[0-9]+ ("'" $[0-9]+)*) ($[eEpP] ($[-\+]? $[0-9a-fA-F]+ ("'" $[0-9a-fA-F]+)*)?)? ("u" | "l" | "U" | "L" | "f" | "F")*
  }
  EscapeSequence {
    "\\" (
      ![xuU] |
      $[0-9] $[0-9] $[0-9]? |
      "x" $[0-9a-fA-F] $[0-9a-fA-F] $[0-9a-fA-F]* |
      "u" $[0-9a-fA-F] $[0-9a-fA-F] $[0-9a-fA-F] $[0-9a-fA-F]  |
      "U" $[0-9a-fA-F] $[0-9a-fA-F] $[0-9a-fA-F] $[0-9a-fA-F] $[0-9a-fA-F] $[0-9a-fA-F] $[0-9a-fA-F] $[0-9a-fA-F]
    )
  }
  SystemLibString {
    "<" (![>\n] | "\\>")* ">"
  }
  identifier {
    $[a-zA-Z_] $[a-zA-Z0-9_]*
  }
  Comment {
    "//" ("\\\\" (![\n] | "\\r"? "\\n") | ![\\\n])* | "/*" ![*]* "\\*"+ (![\/*] ![*]* "\\*"+)* "/"
  }
  LambdaDefaultCapture {
    "=" | "&"
  }
  OperatorName {
    "operator" (
      "+" | "-" | "*" | "/" | "%" | "^" | "&" | "|" | "~" | "!" | "=" | "<" | ">" |
      "+=" | "-=" | "*=" | "/=" | "%=" | "^=" | "&=" | "|=" | "<<" | ">>" | ">>=" |
      "<<=" | "==" | "!=" | "<=" | ">=" | "&&" | "||" | "++" | "--" | "," | "->*" |
      "->" | "()" | "[]"
    )
  }

  UnaryOp { "!" | "~" | "-" | "+" }

  ArithOp<expr> { expr }
  LogicOp<expr> { expr }
  BitOp<expr> { expr }
  CompareOp<expr> { expr }
  UpdateOp<expr> { expr }

  charLiteralStart { "L'" | "u'" | "U'" | "u8'" | "'" }

  charLiteralEnd { "'" }

  charLiteralContent { ![\n']+ }

  stringLiteralStart { "L\"" | "u\"" | "U\"" | "u8\"" | "\"" }

  stringLiteralEnd { "\"" }

  stringLiteralContent { ![\\"\n]+ }
}
