@precedence {
  capture
  subscript
  arguments
  suffix @left
  prefix @left
  pointer @left
  mult @left
  add @left
  bitShift @left
  sizeof
  greaterLess @left
  equal @left
  bitAnd @left
  bitXor @left
  bitOr @left
  logic @left
  params
  array
  specifiers
  cast
  more
  subscriptDesignator
  return
  typeIdentifier
  structName
  namespace
  else @right
  caseLabel
  simpleTypeIdentifier
  reference
  qualifiers
  statement
  pack
  assign @right
  ternary @right
}

@top Program {
  topLevelItem*
}

topLevelItem {
  FunctionDefinition |
  LinkageSpecification |
  Declaration |
  statement |
  TypeDefinition |
  emptyDeclaration |
  NamespaceDefinition |
  UsingDeclaration |
  AliasDeclaration |
  StaticAssertDeclaration |
  TemplateDeclaration |
  TemplateInstantiation |
  FunctionDefinition { constructorOrDestructorDefinition } |
  FunctionDefinition { OperatorCastDefinition } |
  Declaration { OperatorCastDeclaration }
}

@skip { ppSpace } {
  PreprocDirective {
    pp<"include"> (String | SystemLibString | Identifier ArgumentList?) "\n" |
    pp<"define"> Identifier preprocParams? PreprocArg "\n" |
    pp<"if"> PreprocArg "\n" |
    pp<"ifdef" | "ifndef"> Identifier "\n" |
    pp<"else"> "\n" |
    pp<"endif"> "\n" |
    pp<"elif"> PreprocArg "\n" |
    PreprocDirectiveName PreprocArg "\n"
  }
}

preprocParams { "(" commaSep<Identifier | "..."> ")" }

FunctionDefinition {
  Attribute* msCallModifier? declarationSpecifiers declarator CompoundStatement
}

Declaration {
  Attribute* declarationSpecifiers commaSep1<declarator | InitDeclarator> ";"
}

TypeDefinition {
  kw<"typedef"> typeQualifier* typeSpecifier commaSep1<typeDeclarator> ";"
}

declarationSpecifiers {
  (storageClassSpecifier | typeQualifier | AttributeSpecifier | MsDeclspecModifier)* ~specifiers typeSpecifier (storageClassSpecifier | typeQualifier | AttributeSpecifier | MsDeclspecModifier)*
}

LinkageSpecification {
  kw<"extern"> String (FunctionDefinition | Declaration | DeclarationList)
}

AttributeSpecifier {
  kw<"__attribute__"> "(" ArgumentList ")"
}

MsDeclspecModifier {
  kw<"__declspec"> "(" Identifier ")"
}

MsBasedModifier {
  kw<"__based"> ArgumentList
}

msCallModifier {
  @specialize[name=MsCallModifier]<identifier,
    "__cdecl" | "__clrcall" | "__stdcall" | "__fastcall" | "__thiscall" | "__vectorcall">
}

msPointerModifier {
  @specialize[name=MsPointerModifier]<identifier, "__restrict" | "__uptr" | "__sptr" | "_unaligned" | "__unaligned">
}

DeclarationList {
  "{" topLevelItem* "}"
}

declarator {
  PointerDeclarator {
    MsBasedModifier? "*" msPointerModifier* typeQualifier* declarator
  } |
  FunctionDeclarator |
  ArrayDeclarator {
    declarator !array "[" typeQualifier* (expression | "*")? "]"
  } |
  ParenthesizedDeclarator {
    "(" declarator ")"
  } |
  Identifier ~identifier |
  ReferenceDeclarator {
    ("&" | "&&") !reference declarator
  } |
  ScopedIdentifier ~identifier |
  TemplateFunction ~identifier |
  OperatorName |
  DestructorName |
  StructuredBindingDeclarator {
    "[" commaSep1<Identifier ~identifier> "]"
  }
}

FunctionDeclarator {
  declarator !params ParameterList !specifiers AttributeSpecifier*
  (!specifiers (typeQualifier | virtualSpecifier | Noexcept | ThrowSpecifier | TrailingReturnType))*
}

fieldDeclarator {
  PointerDeclarator {
    MsBasedModifier? "*" msPointerModifier* typeQualifier* fieldDeclarator
  } |
  FunctionDeclarator {
    fieldDeclarator !params ParameterList (typeQualifier | virtualSpecifier | Noexcept | ThrowSpecifier | TrailingReturnType)*
  } |
  ArrayDeclarator {
    fieldDeclarator !array "[" typeQualifier* (expression | "*")? "]"
  } |
  ParenthesizedDeclarator {
    "(" fieldDeclarator ")"
  } |
  FieldIdentifier |
  ReferenceDeclarator {
    ("&" | "&&") fieldDeclarator
  } |
  TemplateMethod |
  OperatorName
}

typeDeclarator {
  PointerDeclarator { PointerTypeDeclarator } |
  FunctionDeclarator { FunctionTypeDeclarator } |
  ArrayDeclarator { ArrayTypeDeclarator } |
  ParenthesizedDeclarator { ParenthesizedTypeDeclarator } |
  TypeIdentifier
}

abstractDeclarator {
  AbstractPointerDeclarator |
  AbstractFunctionDeclarator |
  AbstractArrayDeclarator |
  AbstractParenthesizedDeclarator |
  AbstractReferenceDeclarator
}

ParenthesizedTypeDeclarator {
  "(" typeDeclarator ")"
}

AbstractParenthesizedDeclarator {
  "(" abstractDeclarator ")"
}

PointerTypeDeclarator {
  MsBasedModifier? "*" msPointerModifier* typeQualifier* typeDeclarator
}

AbstractPointerDeclarator {
  "*" (!qualifiers typeQualifier)* abstractDeclarator?
}

FunctionTypeDeclarator {
  typeDeclarator !params ParameterList
}

AbstractFunctionDeclarator {
  abstractDeclarator? !params ParameterList (typeQualifier | Noexcept | ThrowSpecifier)* !return TrailingReturnType?
}

ArrayTypeDeclarator {
  typeDeclarator !array "[" typeQualifier* (expression | "*")? "]"
}

AbstractArrayDeclarator {
  abstractDeclarator? !array "[" typeQualifier* (expression | "*")? "]"
}

InitDeclarator {
  declarator "=" (InitializerList | expression) |
  declarator (!arguments ArgumentList | InitializerList)
}

CompoundStatement {
  !statement "{" topLevelItem* !statement "}"
}

storageClassSpecifier {
  @specialize[name=StorageClassSpecifier]<identifier,
    "extern" | "static" | "register" | "inline">
}

typeQualifier {
  @specialize[name=TypeQualifier]<identifier,
    "const" | "volatile" | "restrict" | "_Atomic" | "mutable" | "constexpr">
}

typeSpecifier {
  StructSpecifier {
    kw<"struct"> MsDeclspecModifier? !structName (className | className? virtualSpecifier? BaseClassClause? FieldDeclarationList)
  } |
  UnionSpecifier {
    kw<"union"> MsDeclspecModifier? !structName (className | className? virtualSpecifier? BaseClassClause? FieldDeclarationList)
  } |
  EnumSpecifier {
    kw<"enum"> (kw<"class"> | kw<"struct">)? !structName (className enumBaseClause? EnumeratorList? | EnumeratorList)
  } |
  ClassSpecifier {
    kw<"class"> MsDeclspecModifier? !structName (className | className? virtualSpecifier? BaseClassClause? FieldDeclarationList)
  } |
  DependentType {
    kw<"typename"> typeSpecifier
  } |
  Decltype {
    kw<"decltype"> "(" expression ")"
  } |
  SizedTypeSpecifier |
  primitiveType |
  TemplateType |
  kw<"auto"> |
  (ScopedTypeIdentifier !simpleTypeIdentifier | TypeIdentifier !simpleTypeIdentifier)
}

SizedTypeSpecifier {
  (kw<"signed"> | kw<"unsigned"> | kw<"long"> | kw<"short">)+ (!typeIdentifier TypeIdentifier | primitiveType)?
}

EnumeratorList {
  "{" commaSepTrailing<Enumerator> "}"
}

FieldDeclarationList {
  "{" fieldDeclarationListItem* "}"
}

fieldDeclarationListItem {
  FieldDeclaration |
  TemplateDeclaration |
  FunctionDefinition { InlineMethodDefinition } |
  FunctionDefinition { constructorOrDestructorDefinition } |
  Declaration { constructorOrDestructorDeclaration } |
  FunctionDefinition { OperatorCastDefinition } |
  Declaration { OperatorCastDeclaration } |
  FriendDeclaration |
  AccessSpecifier |
  AliasDeclaration |
  UsingDeclaration |
  TypeDefinition |
  StaticAssertDeclaration
}

FieldDeclaration {
  Attribute* kw<"virtual">? declarationSpecifiers commaSep<fieldDeclarator> (BitfieldClause | InitializerList | "=" (expression | InitializerList))? ";"
}

BitfieldClause {
  ":" expression
}

Enumerator {
  Identifier ("=" expression)?
}

ParameterList {
  "(" ~argOrParam commaSep<(ParameterDeclaration | OptionalParameterDeclaration | VariadicParameterDeclaration | "...")> ")"
}

ParameterDeclaration {
  Attribute* declarationSpecifiers (declarator | abstractDeclarator)?
}

statement {
  CaseStatement |
  nonCaseStatement |
  ForRangeLoop |
  TryStatement |
  ThrowStatement
}

nonCaseStatement {
  LabeledStatement |
  CompoundStatement |
  ExpressionStatement |
  IfStatement |
  SwitchStatement |
  DoStatement |
  WhileStatement |
  ForStatement |
  ReturnStatement |
  BreakStatement |
  ContinueStatement |
  GotoStatement
}

LabeledStatement {
  StatementIdentifier ":" statement
}

ExpressionStatement {
  (expression | CommaExpression)? ";"
}

IfStatement {
  kw<"if"> kw<"constexpr">? ConditionClause statement (!else kw<"else"> statement)?
}

SwitchStatement {
  kw<"switch"> ConditionClause CompoundStatement
}

CaseStatement {
  (kw<"case"> expression | kw<"default">) ":" (!caseLabel (nonCaseStatement | Declaration | TypeDefinition))*
}

WhileStatement {
  kw<"while"> ConditionClause statement
}

DoStatement {
  kw<"do"> statement kw<"while"> ParenthesizedExpression ";"
}

ForStatement {
  kw<"for"> "(" (Declaration | (expression | CommaExpression)? ";") expression? ";" (expression | CommaExpression)? ")" statement
}

ReturnStatement {
  kw<"return"> (expression | CommaExpression)? ";" |
  kw<"return"> InitializerList ";"
}

BreakStatement {
  kw<"break"> ";"
}

ContinueStatement {
  kw<"continue"> ";"
}

GotoStatement {
  kw<"goto"> StatementIdentifier ";"
}

expression {
  ConditionalExpression |
  AssignmentExpression |
  BinaryExpression |
  UnaryExpression |
  UpdateExpression |
  CastExpression |
  PointerExpression |
  SizeofExpression |
  SubscriptExpression |
  CallExpression |
  FieldExpression |
  CompoundLiteralExpression |
  Identifier ~identifier |
  Number |
  String |
  True |
  False |
  kw<"NULL"> |
  ConcatenatedString |
  CharLiteral |
  ParenthesizedExpression |
  TemplateFunction ~identifier |
  ScopedIdentifier ~identifier |
  NewExpression |
  DeleteExpression |
  LambdaExpression |
  ParameterPackExpansion |
  kw<"nullptr"> |
  kw<"this"> |
  RawString
}

CommaExpression {
  expression !more "," (expression | CommaExpression)
}

ConditionalExpression {
  expression !ternary "?" expression ":" expression
}

assignmentLeftExpression {
  (Identifier |
   CallExpression |
   FieldExpression |
   PointerExpression |
   SubscriptExpression |
   ParenthesizedExpression |
   ScopedNamespaceIdentifier)
  !assign // FIXME why is this necessary?
}

AssignmentExpression {
  assignmentLeftExpression !assign (UpdateOp | "=") expression
}

PointerExpression {
  ("*" | "&") !pointer expression
}

UnaryExpression {
  (LogicOp<"!"> | ArithOp<"+" | "-"> | BitOp<"~">) !suffix expression
}

// Note: operators that conflict with other tokens are defined using
// inline rules (so that the tokens can be shared), others directly using
// ArithOp-style token helpers.
BinaryExpression {
  expression !add ArithOp<"+" | "-"> expression |
  expression !mult (ArithOp { "*" } | ArithOp<"/" | "%">) expression |
  expression !logic LogicOp { "||" | "&&" } expression |
  expression !bitOr BitOp<"|"> expression |
  expression !bitXor BitOp<"^"> expression |
  expression !bitAnd BitOp { "&" } expression |
  expression !equal CompareOp<"==" | "!="> expression |
  expression !greaterLess (CompareOp { "<" | ">" } | CompareOp<">=" | "<=">) expression |
  expression !bitShift BitOp<"<<" | ">>"> expression
}

UpdateExpression {
  ("--" | "++") !prefix expression | expression !suffix ("--" | "++")
}

CastExpression {
  "(" TypeDescriptor ")" expression
}

TypeDescriptor {
  typeQualifier* typeSpecifier typeQualifier* abstractDeclarator?
}

SizeofExpression {
  kw<"sizeof"> !sizeof (expression | "(" TypeDescriptor ")") |
  kw<"sizeof"> "..." "(" Identifier ")"
}

SubscriptExpression {
  expression !subscript "[" expression "]"
}

CallExpression {
  expression !arguments ArgumentList |
  primitiveType !arguments ArgumentList
}

ArgumentList {
  "(" ~argOrParam commaSep<(expression | InitializerList)> ")"
}

FieldExpression {
  expression !subscript ("." | "->") FieldIdentifier |
  expression !subscript ("." | "->") (DestructorName | TemplateMethod)
}

CompoundLiteralExpression {
  "(" TypeDescriptor ")" InitializerList |
  (TypeIdentifier | TemplateType | ScopedTypeIdentifier) InitializerList
}

ParenthesizedExpression {
  "(" (expression | CommaExpression) ")"
}

InitializerList {
  "{" commaSepTrailing<InitializerPair | expression | InitializerList> "}"
}

InitializerPair {
  (SubscriptDesignator | FieldDesignator)+ "=" (expression | InitializerList)
}

SubscriptDesignator {
  "[" expression !subscriptDesignator "]"
}

FieldDesignator {
  "." FieldIdentifier
}

@skip {} {
  CharLiteral {
    charLiteralStart (EscapeSequence | charLiteralContent) charLiteralEnd
  }

  String {
    stringLiteralStart (stringLiteralContent | EscapeSequence)* stringLiteralEnd
  }
}

ConcatenatedString {
  (RawString | String) (RawString | String)+
}

TypeIdentifier {
  identifier
}

FieldIdentifier {
  identifier
}

StatementIdentifier {
  identifier
}

Identifier {
  identifier
}

emptyDeclaration {
  typeSpecifier ";"
}

className {
  (TypeIdentifier | ScopedTypeIdentifier | TemplateType) !structName
}

virtualSpecifier {
  @specialize[name=VirtualSpecifier]<identifier, "final" | "override">
}

ExplicitFunctionSpecifier {
  kw<"explicit"> |
  kw<"explicit"> !arguments "(" expression ")"
}

BaseClassClause {
  ":" commaSep1<access? className "..."?>
}

enumBaseClause {
  ":" !typeIdentifier (ScopedTypeIdentifier | TypeIdentifier | SizedTypeSpecifier)
}

TemplateDeclaration {
  kw<"template"> TemplateParameterList (
    emptyDeclaration |
    AliasDeclaration |
    Declaration |
    TemplateDeclaration |
    FunctionDefinition |
    FunctionDefinition { constructorOrDestructorDefinition } |
    FunctionDefinition { OperatorCastDefinition }
  )
}

TemplateInstantiation {
  kw<"template"> declarationSpecifiers? declarator ";"
}

TemplateParameterList {
  "<" commaSep<
    ParameterDeclaration |
    OptionalParameterDeclaration |
    TypeParameterDeclaration |
    VariadicParameterDeclaration |
    VariadicTypeParameterDeclaration |
    OptionalTypeParameterDeclaration |
    TemplateTemplateParameterDeclaration
  > ">"
}

TypeParameterDeclaration {
  (kw<"typename"> | kw<"class">) !typeIdentifier TypeIdentifier?
}

VariadicTypeParameterDeclaration {
  (kw<"typename"> | kw<"class">) "..." !typeIdentifier TypeIdentifier?
}

OptionalTypeParameterDeclaration {
  (kw<"typename"> | kw<"class">) TypeIdentifier? "=" typeSpecifier
}

TemplateTemplateParameterDeclaration {
  kw<"template"> TemplateParameterList (TypeParameterDeclaration | VariadicTypeParameterDeclaration | OptionalTypeParameterDeclaration)
}

OptionalParameterDeclaration {
  declarationSpecifiers declarator? "=" expression
}

VariadicParameterDeclaration {
  declarationSpecifiers (
    VariadicDeclarator |
    ReferenceDeclarator { ("&&" | "&") VariadicDeclarator }
  )
}

VariadicDeclarator {
  "..." Identifier?
}

OperatorCast {
  ((NamespaceIdentifier | TemplateType | ScopedNamespaceIdentifier)? "::")?
  kw<"operator"> declarationSpecifiers !cast abstractDeclarator
}

FieldInitializerList {
  ":" commaSep1<FieldInitializer>
}

FieldInitializer {
  (FieldIdentifier | ScopedFieldIdentifier) !arguments (InitializerList | ArgumentList) "..."?
}

InlineMethodDefinition {
  Attribute* kw<"virtual">? declarationSpecifiers
  fieldDeclarator (CompoundStatement | !more DefaultMethodClause | DeleteMethodClause)
}

OperatorCastDefinition {
  (storageClassSpecifier | typeQualifier | AttributeSpecifier)*
  ~specifiers (kw<"virtual"> | ExplicitFunctionSpecifier)?
  OperatorCast (CompoundStatement | DefaultMethodClause | DeleteMethodClause)
}

OperatorCastDeclaration {
  (kw<"virtual"> | ExplicitFunctionSpecifier)? OperatorCast ("=" expression)? ";"
}

constructorOrDestructorDefinition {
  (storageClassSpecifier | typeQualifier | AttributeSpecifier)* ~specifiers (kw<"virtual"> | ExplicitFunctionSpecifier)? FunctionDeclarator FieldInitializerList? (CompoundStatement | DefaultMethodClause | DeleteMethodClause)
}

constructorOrDestructorDeclaration {
  (kw<"virtual"> | ExplicitFunctionSpecifier)? FunctionDeclarator ";"
}

DefaultMethodClause {
  "=" kw<"default"> ";"
}

DeleteMethodClause {
  "=" kw<"delete"> ";"
}

FriendDeclaration {
  kw<"friend"> (Declaration | FunctionDefinition | (kw<"class"> | kw<"struct"> | kw<"union">)? className ";")
}

AccessSpecifier {
  access ":"
}

AbstractReferenceDeclarator {
  ("&" | "&&") (!reference abstractDeclarator)?
}

TrailingReturnType {
  "->" typeQualifier? typeSpecifier abstractDeclarator?
}

Noexcept {
  kw<"noexcept"> (!arguments "(" expression? ")")?
}

ThrowSpecifier {
  kw<"throw"> "(" commaSep<TypeDescriptor> ")"
}

TemplateType {
  (TypeIdentifier | ScopedTypeIdentifier) ~identifier TemplateArgumentList
}

TemplateMethod {
  (FieldIdentifier | ScopedFieldIdentifier) ~identifier TemplateArgumentList
}

TemplateFunction {
  (Identifier | ScopedIdentifier) ~identifier TemplateArgumentList
}

TemplateArgumentList {
  "<" commaSep<TypeDescriptor | ParameterPackExpansion { TypeDescriptor "..." } | expression> ">"
}

NamespaceDefinition {
  kw<"namespace"> Identifier? DeclarationList
}

UsingDeclaration {
  kw<"using"> kw<"namespace">? (Identifier | ScopedIdentifier) ";"
}

AliasDeclaration {
  kw<"using"> TypeIdentifier "=" TypeDescriptor ";"
}

StaticAssertDeclaration {
  kw<"static_assert"> "(" expression ("," (String | RawString | ConcatenatedString))? ")" ";"
}

ConditionClause {
  "(" ((Declaration | ExpressionStatement)? (expression | CommaExpression) | Declaration { ConditionDeclaration }) ")"
}

ConditionDeclaration {
  declarationSpecifiers declarator ("=" expression | InitializerList)
}

ForRangeLoop {
  kw<"for"> "(" declarationSpecifiers declarator ":" (expression | InitializerList) ")" statement
}

ThrowStatement {
  kw<"throw"> expression? ";"
}

TryStatement {
  kw<"try"> CompoundStatement CatchClause+
}

CatchClause {
  kw<"catch"> ParameterList CompoundStatement
}

Attribute {
  "[[" commaSep1<expression> "]]"
}

NewExpression {
  "::"? kw<"new"> ArgumentList? typeSpecifier (!more NewDeclarator)? (!arguments (ArgumentList | InitializerList))?
}

NewDeclarator {
  "[" expression "]" (!more NewDeclarator)?
}

DeleteExpression {
  "::"? kw<"delete"> (!more "[" "]")? expression
}

LambdaExpression {
  LambdaCaptureSpecifier AbstractFunctionDeclarator? CompoundStatement
}

LambdaCaptureSpecifier {
  "[" (
    ("=" | "&") ("," commaSep1<expression>)? |
    commaSep1<expression> |
    ""
  ) "]" !capture
}

ParameterPackExpansion {
  expression !pack "..."
}

ScopedFieldIdentifier {
  (NamespaceIdentifier | TemplateType | ScopedNamespaceIdentifier)? !namespace "::" (FieldIdentifier | OperatorName | DestructorName)
}

ScopedIdentifier {
  (NamespaceIdentifier | TemplateType | ScopedNamespaceIdentifier)? !namespace "::" (Identifier | OperatorName | DestructorName)
}

ScopedTypeIdentifier {
  (NamespaceIdentifier | TemplateType | ScopedNamespaceIdentifier)? !namespace "::" TypeIdentifier
}

ScopedNamespaceIdentifier {
  (NamespaceIdentifier | TemplateType | ScopedNamespaceIdentifier)? !namespace "::" NamespaceIdentifier
}

NamespaceIdentifier {
  identifier !namespace
}

access { @specialize[name=Access]<identifier, "public" | "private" | "protected"> }

True { @specialize<identifier, "TRUE" | "true"> }

False { @specialize<identifier, "FALSE" | "false"> }

primitiveType {
  @specialize[name=PrimitiveType]<identifier,
    "bool" | "char" | "int" | "float" | "double" | "void" | "size_t" | "ssize_t" |
    "intptr_t" | "uintptr_t" | "charptr_t" | "int8_t" | "int16_t" | "int32_t" |
    "int64_t" | "uint8_t" | "uint16_t" | "uint32_t" | "uint64_t" | "char8_t" |
    "char16_t" | "char32_t" | "char64_t">
}

RawString { rawStringStart rawStringContent* rawStringEnd }

kw<term> { @specialize[name={term}]<identifier, term> }

commaSep<term> { "" | term ("," term)* }

commaSep1<term> { term ("," term)* }

commaSepTrailing<term> { "" | term ("," term?)* }

@skip { whitespace | LineComment | BlockComment | PreprocDirective }

@external tokens rawString from "./tokens" { rawStringStart }

@external tokens rawStringContinue from "./tokens" { rawStringContent, rawStringEnd }

@tokens {
  whitespace {
    ($[ \t\r\n] | "\\" "\r"? "\n")+
  }

  pp[name="#" name]<name> { "#" $[ \t]* name }

  PreprocDirectiveName {
    "#" $[ \t]* $[a-zA-Z] $[a-zA-Z0-9_]*
  }

  @precedence { pp, PreprocDirectiveName }

  PreprocArg {
    ![\n] | "\\\\" "\\r"? "\\n"+
  }

  ppSpace { $[ \t]+ }

  @precedence { "(", PreprocArg, ppSpace }

  Number {
    ("0x" | "0b")? (($[0-9]+ ("'" $[0-9]+)* | "0b" $[0-9]+ ("'" $[0-9]+)* | "0x" $[0-9a-fA-F]+ ("'" $[0-9a-fA-F]+)*) ("." ($[0-9a-fA-F]+ ("'" $[0-9a-fA-F]+)*)?)? | "." $[0-9]+ ("'" $[0-9]+)*) ($[eEpP] ($[-\+]? $[0-9a-fA-F]+ ("'" $[0-9a-fA-F]+)*)?)? ("u" | "l" | "U" | "L" | "f" | "F")*
  }

  @precedence { Number, "." }

  EscapeSequence {
    "\\" (
      ![xuU] |
      $[0-9] $[0-9] $[0-9]? |
      "x" $[0-9a-fA-F] $[0-9a-fA-F] $[0-9a-fA-F]* |
      "u" $[0-9a-fA-F] $[0-9a-fA-F] $[0-9a-fA-F] $[0-9a-fA-F]  |
      "U" $[0-9a-fA-F] $[0-9a-fA-F] $[0-9a-fA-F] $[0-9a-fA-F] $[0-9a-fA-F] $[0-9a-fA-F] $[0-9a-fA-F] $[0-9a-fA-F]
    )
  }

  SystemLibString {
    "<" (![>\n] | "\\>")* ">"
  }

  identifier {
    $[a-zA-Z_] $[a-zA-Z0-9_]*
  }

  DestructorName {
    "~" $[ \t]* identifier
  }

  @precedence { DestructorName, BitOp }

  LineComment { "//" ("\\" (![\n] | "\\r"? "\\n") | ![\n])* }

  BlockComment { "/*" blockCommentRest }

  blockCommentRest { ![*] blockCommentRest | "*" blockCommentAfterStar }

  blockCommentAfterStar { "/" | "*" blockCommentAfterStar | ![/*] blockCommentRest }

  @precedence { LineComment, BlockComment, ArithOp }

  OperatorName {
    "operator" (UpdateOp | $[=+\-*/%^~!] | "<" $[<=]? | ">" $[>=]? | $[!=] "=" | "&" "&"? | "|" "|"? | "->" | "()" | "[]")
  }

  @precedence { OperatorName, identifier }

  ArithOp<expr> { expr }

  BitOp<expr> { expr }

  CompareOp<expr> { expr }

  LogicOp<expr> { expr }

  UpdateOp {
    ($[*/%+\-&^|] | "<<" | ">>") "="
  }

  charLiteralStart { "L'" | "u'" | "U'" | "u8'" | "'" }

  charLiteralEnd { "'" }

  charLiteralContent { ![\\\n']+ }

  stringLiteralStart { "L\"" | "u\"" | "U\"" | "u8\"" | "\"" }

  stringLiteralEnd { "\"" }

  stringLiteralContent { ![\\\n"]+ }

  @precedence { stringLiteralStart, charLiteralStart, identifier }
}
